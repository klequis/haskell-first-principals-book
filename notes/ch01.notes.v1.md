A functions is a relation between as set of possible inputs and a set of possible outputs. The function itself defines the relationship.

A function will always return the same output for the same input. Multiple inputs can produce the same output, but a given input will always have the same output.

Lambda calculus has three basic lamda terms (components)

1. expressions: Expressions is a superset of all things in Haskell
2. variables: Vairables have not meaning or value; they are only names for potential inputs to functions.
3. abstractions: An abstraction is a function

**Application** is the act of applying a lambda function to an argument. When we apply an abstraction to artuments, we replace the names (parameter names) with values, making it **concrete**.

**Free variables** are variables in the body expression that are not named in the head. So in the expression `位x.xy`, `x` is bound and `y` is free.

Alpha equivalence

`位xy.yx` and `位ab.ba` are equivalent
`位x.xz` and `位y.yz` are equivalent because the free variable is left alone
`位x.xz` and `位x.xy` are not equivalent

## Multiple arguments

`位xy.xy` is shorthand for 2 nested lamdas each with one argument, i.e., `位x(位y.xy)`

```haskell
(位xy.xy) 1 2
(位x.(位y.xy)) 1, 2
(位y.1y) 2 -- replace x with 1
1 2 -- replace y with 2
```

```haskell
 位xy.xy
(位xy.xy)(位z.a) 1
(位x.(位y.xy))(位z.a) 1 -- x == (位z.a)
(位y.(位z.a)y) 1 -- y == 1
(位z.a)1 -- eliminate the head
a -- and the answer is a
-- I only partly get that
```

```haskell
(位xyz.xz(yz))(位mn.m)(位p.p)

(位x.位y.位z.xz(yz))(位m.位n.m)(位p.p)

   (位y.位z.(位m.位n.m)z(yz))(位p.p)

      (位z.(位m.位n.m)(z)((位p.p)z))

      位z(位n.z)((位p.p)z)

      位z(z)((位p.p)z)

      位z(z)(z)

      位z(位n.z)(z)
```

Questions - the book does not specify what the answers are. These are my guesses.

```haskell
位xy.xz
位x.位y.xz
"C" 位z.(位x.xz) (wrong, it is "b")
'b' is . which makes more sense
-- div
位xy.xxy
位x.位y.xxy
"C" 位a.(位b.aab) (correct)
-- div
位xyz.zx
位x(位y(位z.zx))
位x(位z.zx)
"B" 位tos.st (correct)
```

## 1.8 Combinators (pg. 14)

A combinator is a lamda term with no free variables. Combinators, as the name suggests, serve only to combine the arguments they are given. In other words:

- Every term in the body appears in the head.
- or: They are a special class of lambda expressions that can only combine the arguments they are given, without introducing any new values or random data.

## 1.9 Divergence (pg. 15)

Divergence here means that the reduction process never terminates or ends. Reducing terms should ordinarily converge to beta normal form, and divergence is the opposite of convergence, or normal form. Normal form is also sometimes called _canonical form_.

---

## 1.11 Chapter exercises

Which are combinators

1. .ヰヰ yes
2. ヰ.ю no
3. ヰ.ヰ(ю) yes
4. ヰ.ヰ(юヰ) yes
5. ヰ.ヰ(юヰ) no

---

Normal or diverge

1. .ヰヰ -- normal

```
= a
  位x.xxx
```

2. (.ю)(.) -- diverge

```
= a
  (位z.zz)(位y.yy)
= b
  (位y.yy)(位y.yy)
= c
  (位y.yy)(位y.yy)
```

So, looks to me if you replace (位y.yy) with (位y.yy) you get (位y.yy)(位y.yy) and then have to replace (位y.yy) with (位y.yy) again which is never ending, therefore - diverge

3. (.ヰヰ) -- normal
   zzz

---

Beta reduce

## 1. (位abc.cba)zz(位wv.w)

My first try, I got stuck

```haskell
  (位abc.cba)zz(位wv.w)
=
  (位.cb(zz))
=
  (位.c(w)(zz))
```

Notes:

- (= a) I originally thought zz was one variable and `a` was replaced by `zz`, but it is used as 2 variables where

  - the first `z` replaces `a` and
  - the second `z` replaces `b`.

- (= b)
  - `(位wv.w)` replaces `c`, including the parens
  - there are no more variables in the first lambda's head so it goes away

```haskell
  (位abc.cba)zz(位wv.w)
= a
  (位bc.cbz)z(位wv.w)
= b
  (位c.czz)(位wv.w)
= c
  (位wv.w)zz
= d
   (位v.z)z
= e
  z
```

## 2. (位x.位y.xyy)(位a.a)b

My try

```haskell
  (位x.位y.xyy)(位a.a)b
= a
  (位y.(位a.a)yy)(位a.a)b
= b
  (位y.y)y(位a.a)b
```

Answer

(=b)

- `x` is replaced with (位a.a); got that
- `y` is replace with `b` -> `bb`
- `a` is replaced with `bb`

```haskell
= a
  (位x.位y.xyy)(位a.a)b
= b
  (位y.(位a.a)yy)b
= c
  (位a.a)bb
= d
  bb
```

# 3 (位y.y)(位x.xx)(位z.zq)

```haskell
= a
  (位y.y)(位x.xx)(位z.zq)
= b
  (位x.xx)(位z.zq)
= c
  (位z.zq)q
= d
  qq
```

# 4 (位z.z)(位z.zz)(位z.zy)

```haskell
= a
  (位z.z)(位z.zz)(位z.zy)
= b
  (位z.zz)(位z.zy)
= c
  (位z.zy)(位z.zy)
= d
  (位z.zy)y
= e
  yy
```

# 5 (位x.位y.xyy)(位y.y)y

My answer, different steps but same answer

```haskell
= a
  (位x.位y.xyy)(位y.y)y
= b
  (位y.(位y.y)yy)y -- replace (位y.y) with the first y from yy
= c
  ((位y.y)y)y -- 位y.(位y.y)yy -> ((位y.y)y)y
= d
  (y)y
= e
  yy

```

Books answer

```
= a
  (..ヰ)(.)
= b
  (.(.))
= c
  (.)
= d
  
```

## 6. (位a.aa)(位b.ba)c

Try 1

```
= a
  (位a.aa)(位b.ba)c
= b
  ((位b.ba)(位b.ba))c -- I should not have the outer () here.
= c
  ((位b.ba)a)c
= d
  (aa)c
= e ??
  caa
```

Try 2

I tried to do the substitution on `(位b.ba)c` first and got the same wrong answer

```
= a
  (位a.aa)(位b.ba)c
= b
  (位a.aa)ca
= c
 (cc)a
= cca
```

Book answer

- So far, it appears if you have two identical terms, e.g., (.)(.) it reduces to (.)

```
= a
  (.)(.)
= b -- replace `a` in `(.)` with `(.)`
  (.)(.)
= c -- replace `b` in `(.)` with `(.)`
  (.)
= d -- replace `b` in `(.)` with `a`
  ****
```

(ヰ.ヰ())(.)(.)

## 7. (xyz.xz(yz))(x.z)(x.a)

```
= a
  (xyz.xz(yz))(x.z)(x.a)

= b -- replace x in xyz.xz with (yz)
  (yz.yzz)(x.z)(x.a)

= c -- replace y in (yz.yzz) with (x.z)
  (z.(x.z)zz)(x.a)

= d -- replace z in (x.z) with z
  (z.zz)(x.a)

= e -- replace z in (z.zz) with (x.a)
  (x.a)(x.a)

= f -- two terms the same -> reduce to one
  (x.a)
```

One key to this on is that there is a bound z in the first term and a free z in the second term. They are not the same z so need to rename one of them so, rename the z in the first term to z'.

> From another source, renaming is stated as: "If the substitution would bring a free variable of E in an expression where this variable occurs bound, we rename the bound variable before performing the substitution."

(ヰ.ヰ())(.)(.) -> (yz'.(.)z'(yz))(.)
('.(.)'())(.)

```
= a
  (ヰ.ヰ())(.)(.)

= b: replce x in first head with (.) and rename z in first term to z'
  ('.(.)'())(.)

= c: replace y with (.)
  '.(.)'((.))

= d
  '.((.))
= e
  **'.ю**
```
