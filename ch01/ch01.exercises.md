# Chapter 1 Exercises

## Intermission: Equivalence exercises

1. `位xy.xz`: B `位mn.mz`
2. `位xy.xxy`: C `位a.(位b.aab)`
3. `位xyz.zx`: B `位tos.st`

## Exercises

**Which are combinators?**

1. `位x.xxx` : Yes
2. `位xy.zx` : No
3. `位xyz.xy(zx)` : Yes
4. `位xyz.xy(zxy)` : Yes
5. `位xy.xy(zxy)` : No

**Normal form or diverge?**

1. 位x.xxx : No

2. (位z.zz)(位y.yy)
   (位y.yy)(位y.yy) : Yes

3. (位x.xxx)z
   zzz : No

**Beta Reduction**

# 1. (位abc.cba)zz(位wv.w)

```haskell
(位abc.cba)zz(位wv.w)

(位bc.cbz)z(位wv.w)

(位c.czz)(位wv.w)

(位wv.w)zz

(位v.z)z

z

```

# 2. (位x.位y.xyy)(位a.a)b

```
(位x.位y.xyy)(位a.a)b

(位y.(位a.a)yy)b

(位a.a)bb

bb
```

# 3 (位y.y)(位x.xx)(位z.zq)

```
(位y.y)(位x.xx)(位z.zq)

(位x.xx)(位z.zq)

(位z.zq)(位z.zq)

(位z.zq)q

qq

```

# 4 (位z.z)(位z.zz)(位z.zy)

```
(位z.z)(位z.zz)(位z.zy)

(位z.zz)(位z.zy)

(位z.zy)(位z.zy)

(位z.zy)y

yy

```

# 5 (位x.位y.xyy)(位y.y)y

```
a. (位x.位y.xyy)(位y.y)y

b. (位y.(位y.y)yy)y | (.(.))

c. (位y.yy)y | (.)

yy

```

I got the same answer but, in (c) I replaced the inner/second `位y` with the innder `yy`. The book replaces the outer/first `位y` with `y`. _Is my approach correct?_

# 6. (位a.aa)(位b.ba)c

```
(位a.aa)(位b.ba)c

(位b.ba)(位b.ba)c

(位b.ba)ac

aac

```

# 7. (位xyz.xz(yz))(位x.z)(位x.a)

Book Solution

```haskell
(位xyz.xz(yz))(位x.z)(位x.a) -- a
(位yz'.(位x.z)z'(yz))(位x.a) -- b

位z'.(位x.z)z' ((位x.a)z) -- c
位z'.z        ((位x.a)z) -- d

(d)
-- I apply z' to 位x.z
-- remove the head and z goes away because when a 位 is applied to a free & the body has a free variable, the head is removed and the free variable is tossed. All that remains is the term t which the 位 is being applied.

-- When a 位 with no bound variables is applied to a variable/term, the variable/term it is applied to goes away because it is not referenced in the body of the 位. What remains is the free variables.
-- Example (位x.z)a -> z
   -- a is tossed and the head is removed leave only z


位z'.za -- e
```

My try

```haskell
(位xyz.xz(yz))(位x.z)(位x.a)
(位xyz'.xz'(yz))(位x.z)(位x.a)
(位yz'.(位x.z)z'(yz))(位x.a)
(位z'.(位x.z)z'((位x.a)z))
(位z'.z((位x.a)z))
(位z'.za)


```

Try again

```haskell
(位xyz.xz(yz))(位x.z)(位x.a)
-- alpha replace first z with z'
(位xyz'.xz'(yz))(位x.z)(位x.a)
-- replace x with (位x.z)
(位yz'.(位x.z)z'(yz))(位x.a)
-- replace y with (位x.a)
(位z'.(位x.z)z'((位x.a)z))
-- replace the first 位x with z'
(位z'.z((位x.a)z))
-- replace 位x with z
(位z'.z((a)))
-- remove paren
位z'.za
```

OK, I got it! -- Yeah!!

# 7. Book Answer

Translation

```haskell
-- (ヰ.ヰ())(.)(.)
(位xyz.xz(yz))(位x.z)(位x.a)

-- (...ヰ())(.)(.)
(位x.位y.位z.xz(yz))(位x.z)(位x.a)

-- (.1.(.)1(1))(.)
(位y.位z1.(位x.z)z1(yz1))(位x.a)

-- (1.(.)(1)((.)1))
(位z1.(位x.z)(z1)((位x.a)z1))

-- (1.((.)(1)))
(位z1.z((位x.a)(z1)))

-- (1.ю)
(位z1.za)
```

Just answer

```haskell
(位xyz.xz(yz))(位x.z)(位x.a)

(位x.位y.位z.xz(yz))(位x.z)(位x.a)

(位y.位z1.(位x.z)z1(yz1))(位x.a)
--  apply 位y to (位x.a)
(位z1.(位x.z)(z1)((位x.a)z1))
-- apply 位x to fist (z1)
(位z1.z((位x.a)(z1)))
-- apply 位x to (z1)
(位z1.za)
```

Analyze 1

```haskell
(位xyz.xz(yz))(位x.z)(位x.a)



(位x.位y.位z.xz(yz)) (位x.z) (位x.a)

(位y.位z1.(位x.z) z1 (yz1)) (位x.a)

(位z1.(位x.z) (z1) ((位x.a)z1))

(位z1.z ((位x.a) (z1)))

(位z1.za)
```
